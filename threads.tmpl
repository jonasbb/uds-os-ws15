			+--------------------+
			|         OS         |
			| PROJECT 1: THREADS |
			|   DESIGN DOCUMENT  |
			+--------------------+
				   
---- GROUP ----

>> Fill in the names and email addresses of your group members.

FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.
NebenlÃ¤ufige Programmierung (Slides + Script) SS14 at UdS by Hermanns

			     ALARM CLOCK
			     ===========

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> A2: Briefly describe what happens in a call to timer_sleep(),
>> including the effects of the timer interrupt handler.

>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

---- SYNCHRONIZATION ----

>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

---- RATIONALE ----

>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?


    		     PROD/CONS
	  		     =========

---- SYNCHRONIZATION ----

>> B1: How does your solution guarantee that consumers will hold until
>> there is something to consume in the buffer?
The pop method waits if the buffer is empty. It waits on the non_empty condition,
which is only ever signaled by the put method after it has put something in the buffer.
Only one consumer is ever woken up, so that the buffer is always non_empty after the
return from cond_wait. To be sure and to future proove our code we recheck the condition
anyway in a while loop and re-wait on the same condition if the buffer is empty.
This way we could also use broadcast instead of signal to wake up threads.

>> B2: How does your solution guarantee that producers will hold until
>> there is some free space in the buffer?
Analoge to B1, just with switched pop/put methods and non_empty/non_full conditions.

The put method waits if the buffer is full. It waits on the non_full condition,
which is only ever signaled by the pop method after it has popped something from the buffer.
Only one producer is ever woken up, so that the buffer is always non_full after the
return from cond_wait. To be sure and to future proove our code we recheck the condition
anyway in a while loop and re-wait on the same condition if the buffer is full.
This way we could also use broadcast instead of signal to wake up threads.

>> B3: How does your solution preserve a FIFO semantics i.e., the first
>> character produced will be the first to be consumed?
We use a ringbuffer `buf` with the pointer `buf_in` and `buf_out`. The pointers
point to the next place in the buffer to write to or read from. Because they always
move in the same direction (increasing, wrap aroung to 0 at buffer size) characters
are read in the same order they were written in, thus preserving the FIFO semantics.

---- RATIONALE ----

>> B4: Give an intuition for why your program preserves safety.
Only the access to the variables `buf*` could potentially create race conditions.
We have three positions, where we access the variables, in producer_consumer, in put,
and in pop. In producer_consumer only one thread runs at this time, thus no race conditions
can occur. put and pop are called from producer and consumer which run potentially als multiple
threads in parallel. Both, put and pop, have lock_acquire as their first call, both on the same lock.
The access to `buf*` variables in both functions is therefore always protected by the lock and no
race conditions can occure.

>> B5: Why did you choose this design? Did you consider other design 
>> alternatives? In what ways is it superior to another design you considered?
We learned this exact design in NP (see sources on top) so it was the easiest to implement.
Furthermore, the documentation already contains code for put/pop which it was compared to
to check for correct implementation of the critical sections.
http://courses.mpi-sws.org/os-ws15/assignments/pintos/pintos_6.html#SEC101

We did not consider other designs, because it is the most familiar design.

- (no other designs to compare to)

			     NARROW BRIDGE
			     =============

---- SYNCHRONIZATION ----

>> C1: How does your solution guarantee that no more that 3 vehicles 
>> are crossing the bridge in the same direction?

>> C2: What prevents vehicles from opposite directions from crossing the
>> bridge simultaneously?

>> C3: How does your solution grant priority to emergency vehicles over
>> the queue of vehicles ahead in the same direction?

>> C4: How do you guarantee that despite having priority, emergency vehicles
>> do not start crossing the bridge while there are still vehicles crossing
>> it in the oposite direction?

>> C5: Explain with examples why your solution does not preserve neither 
>> fairness nor freedom from starvation, other than what has been indicated 
>> for emergency vehicles.

---- RATIONALE ----

>> C6: Why did you choose this design? Did you consider other design 
>> alternatives? In what ways is it superior to another design you considered?


			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future semesters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the semester.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future semesters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future semesters or the remaining projects?

>> Any other comments?
